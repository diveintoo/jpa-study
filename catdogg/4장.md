# 4장

## @Entity

- 테이블과 매핑할 클래스
- 속성 : name
- 기본 생성자 필수
 

## @Table

- 엔티티와 매핑할 테이블 지정
- 속성 : name, catalog, scheme, uniqueConstraints(DDL)

 
## 데이터베이스 스키마 자동 생성
- create, create-drop, update, validate, none
- 운영 DB에서는 create, create-drop, update 같은 옵션은 사용 지양

### DDL 생성 기능
- nullable, length 
- DDL을 자동 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않는다.

- 참고 : validation 처리 - nullable <-> NotNull, NotEmpty ...
 

## 기본 키 매핑
- 직접 할당 : @Id
- 자동 생성 : 
     - IDENTITY : 기본키 생성을 데이터베이스에 위임
     - SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본키 할당
     - TABLE : 키 생성 테이블 사용

 
### 1. 기본 키 직접 할당 전략
- @Id 로 매핑
- em.persist()로 엔티티를 저장하기 전에 어플리케이션에서 기본키를 직접 할당하는 방법
- 식별자 값 없이 저장하면 예외 발생

### 2. IDENTITY 전략
- 기본키 생성을 데이터베이스에 위임하는 전략
- 데이터베이스에 값을 저장할 때 ID 컬럼을 비워두면 데이터베이스가 순서대로 값을 채워준다.
- 직접 할당이 아닌 경우 @GeneratedValue 어노테이션을 사용하고 식별자 생성 전략을 선택해야한다.
- 엔티티가 영속 상태가 되려면 식별자가 반드시 필요하다. 
    - 이 전략은 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다.

### 3. SEQUENCE 전략
- 시퀀스 : 유일한 값을 순서대로 생성하는 데이터베이스 오브젝트
- @SequenceGenerator를 사용해서 시퀀스 생성기 등록
- 동작 방식 : em.persist()를 호출할 때 먼저 데이터베이스 시퀀스를 사용해서 식별자를 조회 -> 조회한 식별자를 엔티티에 할당한 뒤 엔티티를 영속성 컨텍스트에 저장 -> 트랜잭션을 커밋해서 flush가 일어나면 엔티티를 데이터베이스에 저장
- 최적화 : 시퀀스를 통해 식별자를 조회하는 추가 작업이 필요하기 때문에 2번의 통신이 필요하다. (1. 식별자를 구하기 위해 시퀀스 조회 2. 조회한 시퀀스를 기본키로 사용해서 데이터베이스에 저장) 이때, JPA는 시퀀스에 접근하는 횟수를 줄이기 위해 @SequenceGenerator.allocationSize를 사용해서 설정한 값만큼 한번에 시퀀스 값을 증가시키고 그만큼 메모리에 시퀀스 값을 할당한다. 시퀀스 값을 어플리케이션 단에서 선점하기 때문에 여러 JVM이 동시에 동작해도 기본 키 값이 충돌하지 않는다. 하지만 시퀀스 값이 한번에 많이 증가한다는 단점이 존재한다.


### 4. TABLE 전략
- 키를 생성하는 테이블을 만들고, 이름과 값으로 사용할 컬럼을 만들어서 데이터베이스 시퀀스를 흉내내는 전략이다.
- 테이블을 사용하기 때문에 모든 데이터베이스에 적용할 수 있다. 
- 시퀀스 -> 테이블 을 제외하고 시퀀스 전략과 내부 동작방식은 같다.


### 5. AUTO 전략
- IDENTITY, SEQUENCE, TABLE 전략 중 자동으로 선택한다.
- ex 오라클 - SEQUENCE, Mysql - IDENTITY
- 아직 키 생성 전략이 정해지지 않았을 때에 사용하면 편리하다. 왜냐하면 데이터베이스를 변경해도 코드를 수정할 필요가 없기 때문이다.

### 6. 기본키 매핑 정리
- 영속성 컨텍스트는 엔티티를 식별자 값으로 구분하기에 영속 상태가 되려면 반드시 식별자값인 @Id 가 있어야한다. 
- 식별자 선택 전략 : null 허용 x, 유일, 변화 x
- 테이블의 기본키 선택 전략 : 자연키(비즈니스에 의미 있는 키) / 대리키(비즈니스와 관련 없는 임의 키, 대체키)
- 자연키 보다는 대리키를 권장 : 비즈니스 로직과 관련된 자연키를 사용하면 나중에 대처가 힘들다. 즉, 미래까지 만족시켜주는 자연키를 찾기가 쉽지 않다. 반면에 대리키는 비즈니스와 무관한 임의의 값이기에 요구사항이 변경되어도 기본키가 변경되는 일이 드물다.)
- 기본키는 변하면 안된다는 원칙때문에 저장된 엔티티의 기본키가 변경되면 예외를 발생시키거나 정상 동작을 하지 않는다.

 
## 필드와 컬럼 매핑
- @Column : 컬럼 매핑
     - 속성 : name, insertable, updatable, table, nullable, unique, columnDefinitaion, length, percision, scale
- @Enumerated : enum 타입 매핑
     - 속성 : value(EnumType.ORDINAL, EnumType.STRING)
- @Temporal : 날짜 타입 매핑
- @Lob : BLOB, CLOB 타입 매핑
- @Transient : 특정 필드를 데이터베이스에 매핑하지 않음
- @Access : JPA가 엔티티에 접근하는 방식을 지정한다. 만약 설정하지 않으면 @Id 어노테이션의 위치를 기준으로 접근 방식이 설정된다. (필드접근, 프로퍼티 접근)
