# 8장 프록시와 연관관계 관리

## 8.1 프록시
- 지연로딩 : JPA는 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 제공한다
- 프록시 객체 : 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대상에 데이터베이스 조회를 지연할 수 있는 
가짜 객체가 필요한데 이것을 프록시 객체라고 한다.
- Hibernate는 지연 로딩 지원을 위해 두가지 방법을 제공한다.
  1. 프록시를 사용하는 방법
  2. 바이트코드를 수정하는 방법 (좀더 복잡)


### 8.1.1 프록시 기초
- em.find() 시 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회한다.
- 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루고 싶으면 em.getReference() 메소드를 사용하면 된다. 
  - 데이터베이스 접근을 위임한 프록시 객체를 반환
- 프록시 객체 초기화
  - 프록시 객체는 실제 객체에 대한 참조(taget)을 보관한다. 
  - 프록시 객체의 메소드 호출 시 프록시 객체는 실제 객체의 메소드를 호출한다.

#### 프록시의 특징
- 프록시 클래스는 실제 클래스를 상속 받아 만들어지므로 실제 클래스와 겉 모양이 같기 때문에 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.
- 프록시 객체는 실제 객체에 대한 참조를 보관한다. 그리고, 프록시 객체의 메소드를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.
- 프록시 초기화 과정
 
    ![image](https://user-images.githubusercontent.com/61506233/158010146-74cb85cb-23a7-4e85-a5d2-3c7fcd3ce619.png)

- 프록시 객체는 처음 사용할 때 한 번만 초기화된다.
- 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.
- 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시에 주의해서 사용해야 한다.
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없으므로 em.getReference()를 호출해도 프록시가 아닌 실제 엔티티를 반환한다.
- 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태의 프록시를 초기화하면 문제가 발생한다. 하이버네이트는 org.hibernate.LazyInitializationException 예외를 발생시킨다.

### 8.1.2 프록시와 식별자
- 식별자 값을 조회하는 team.getId()를 호출 해도 프록시를 초기화하지 않는다. 
- (단, @Access(AccessType.PROPERTY)로 설정한 경우에만 초기화하지 않는다.) 
- 엔티티 접근 방식을 필드 (@Access(AccessType.FIELD))로 설정하면 
JPA는 getId() 메소드가 id만 조회하는 메소드인지 다른 필드까지 활용해서 어떤 일을 하는 메소드인지 알지 못하므로 프록시 객체를 초기화한다.
- PersistenceUnitUtil.isLoaded(Object entity) 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 확인할 수 있다.
- 하이버네이트의 initialize() 메소드를 사용하면 프록시를 강제로 초기화할 수 있다.

### 8.1.3 프록시 확인
- 조회된 엔티티가 진짜 엔티티인지 프록시로 조회한 것인지 확인하려면 클래스 명을 직접 출력해보면 된다.

## 8.2 즉시 로딩과 지연 로딩
- 즉시 로딩
  - 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.
  - @ManyToOne(fetch = FetchType.EAGER)
- 지연 로딩
  - 연관된 엔티티를 실제 사용할 때 조회한다.
  - @ManyToOne(getch = FetchType.LAZY)

### 8.2.1 즉시 로딩
```java
@ManyToOne(fetch = FetchType.EAGER)
@JoinColumn(name= "TEAM_ID")
private Team team;
```
- 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용한다.
- 참고 : NULL 제약조건과 JPA 조인 전략 
  - 현재 회원 테이블에 TEAM_ID 외래 키는 NULL 값을 허용하고 있다. 
  - 따라서 팀에 소속되지 않은 회원이 있을 가능성이 있다. 
  - 팀에 소속하지 않은 회원과 팀을 내부 조인 하면 팀은 물론이고 회원 데이터도 조회할 수 없다.
  - 하지만 외부 조인보다 내부 조인이 성능과 최적화에서 더 유리하다.
  - 내부 조인을 사용하려면?
    - 외래 키에 NOT NULL 제약 조건을 설정하면 값이 있는 것을 보장한다. NOT NULL을 표현하는 방법은 두 가지가 있다.
       - @JoinColumn(name = "TEAM_ID", nullable = false)
       - @ManyToOne(fetch = FetchType.EAGER, optional = false)
  - 정리하자면 JPA는 선택적 관계면 외부 조인을 사용하고 필수 관계면 내부 조인을 사용한다.

### 8.2.2 지연 로딩
```java
Member member = em.find(Member.class,"member1");
Team team = member.getTeam();	// 프록시 객체
team.getName(); // 팀 객체 실제 사용
```
- 컬렉션인 경우 - @ManyToOne, @OneToOne : 즉시로딩
- @OneToMany, @ManyToMany : 지연 로딩 - 무조건 외부 조인을 사용

### 8.2.3 즉시 로딩, 지연로딩 정리
- 지연 로딩 : 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다.
- 즉시 로딩 : 연관된 엔티티를 즉시 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다.

## 8.3 지연로딩 활용
### 8.3.1 컬렉션 래퍼 
하이버네이트는 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로 원본 컬렉션을 하이버네이트가 제공하는 내장 컬렉션으로 변경하는데 이것을 컬렉션 래퍼라 한다.
```java
@OneToMany(mappedBy = "member", fetch = FetchType.LAZY)
private List<Order> orders;
}
```
### 8.3.2 JPA 기본 페치 전략
- @ManyToOne, @OneToOne: 즉시 로딩(FetchType.EAGER)
- @OneToMany, @ManyToMany: 지연 로딩(FetchType.LAZY)


- JPA의 기본 페치 전략은 연관된 엔티티가 하나면 즉시 로딩을, 컬렉션이면 지연 로딩을 사용한다. 
- 하지만 추천하는 방법은 모든 연관관계에 지연 로딩을 사용하는 것이다. 이후 개발 완료 단계에 왔을 때, 실제 사용하는 상황을 보고 꼭 필요한 곳에만 즉시 로딩을 사용하도록 최적화하면 된다.

### 8.3.3 컬렉션에 FetchType.EAGER 사용 시 주의점
- 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다. 
- 컬렉션 즉시 로딩은 항상 외부 조인을 사용한다. 
	- @ManyToOne, @OneToOne
		- (optional = false) : 내부 조인
		- (optional = true) : 외부 조인
	- @OneToMany, @ManyToMany
		- (optional = false) : 외부 조인
		- (optional = true) : 외부 조인


## 8.4 영속성 전이: CASCADE
- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이(transitive persistence) 기능을 사용하면 된다. JPA는 CASCADE 옵션으로 영속성 전이를 제공한다.
- JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태이여야 한다. 따라서 예제를 보면 부모 엔티티, 자식 엔티티 각각 영속 상태로 만든다.
- 영속성 전이는 연관관계를 매핑하는 것과는 아무 관련이 없다. 단지 엔티티를 영속화할 때 연관된 엔티티도 같이 영속화하는 편리함을 제공할 뿐이다.
- CASCADE의 종류
```java
public enum CascadeType {
    ALL, //모두 적용
    PERSIST, //영속
    MERGE, //병합
    REMOVE, //삭제
    REFRESH, //REFRESH
    DETACH //DETACH
}
```

CascadeType.PERSIST, CascadeType.REMOVE는 em.persist(), em.remove()를 실행할 때 바로 전이가 발생하지 않고 플러시를 호출할 때 전이가 발생한다.

## 8.5 고아 객체
JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아 객체 제거라 한다. 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제되도록 작성해보자.
```java
    @OneToMany(mappedBy = "parent", orphanRemoval = true)
    private List<Child> children = new ArrayList<Child>();
}
```
- 고아 객체 제거 기능은 영속성 컨텍스트를 플러시할 때 적용되므로 플러시 시점에 DELETE SQL이 실행된다.
- 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능이다. 만약 삭제한 엔티티를 다른 곳에서도 참조한다면 문제가 발생할 수 있다. 이런 이유로 orphanRemovel은 @OneToOne, @OneToMany에만 사용할 수 있다.
- 부모를 제거하면 자식도 같이 제거할 수 있다. CadecadeType.REMOVE를 설정하면 가능하다.

## 8.6 영속성 전이 + 고아 객체, 생명주기
- CascadeType.ALL + orphanRemoval = true를 동시에 사용하면 어떻게 될까?
	- 일반적으로 엔티티는 EntityManager.persist()를 통해 영속화되고 EntityManager.remove()를 통해 제거된다. 이것은 엔티티 스스로 생명주기를 관리한다는 뜻이다. 그런데 두 옵션을 모두 활성화하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있다.
영속성 전이는 DDD의 Aggregate Root개념을 구현할 때 사용하면 편리하다

## 8.7 정리
- JPA 구현체들은 객체 그래프를 마음껏 탐색할 수 있도록 지원하는데 이때 프록시 기술을 사용한다.
- 객체를 조회할 때 연관된 객체를 즉시 로딩하는 방법을 즉시 로딩이라 하고, 연관된 객체를 지연해서 로딩하는 방법을 지연 로딩이라 한다.
- 객체를 저장하거나 삭제할 때 연관된 객체도 함께 저장하거나 삭제할 수 있는데 이것을 영속성 전이라 한다.
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하려면 고아 객체 제거 기능을 사용하면 된다.
