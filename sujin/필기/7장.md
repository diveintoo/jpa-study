_본 글은 김영한님의 <자바 ORM 표준 JPA 프로그래밍>을 읽고 공부한 내용을 정리한 글입니다._

> 1. 상속 관계 매핑
2. @MappedSuperclass
3. 복합 키와 식별 관계 매핑
4. 조인 테이블
5. 엔티티 하나에 여러 테이블 매핑

## 1. 상속 관계 매핑
관계형 데이터베이스에는 객체지향 언어에서 다루는 상속이라는 개념이 없습니다.
대신에 **슈퍼타입 서브타입 관계**라는 모델링 기법이 있답니다.
슈퍼타입 서브타입 논리 모델을 실제 물리 모델인 테이블로 구현할 때는 3가지 방법을 선택할 수 있습니다.
하나씩 알아보도록 하죠.
### 1.1 조인 전략
조인 전략은 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략입니다.
테이블에는 타입의 개념이 없기 때문에 DTYPE 컬럼을 구분 컬럼으로 사용합니다.

- 장점
   - 테이블이 정규화됩니다.
   - 외래 키 참조 무결성 제약조건을 활용할 수 있습니다.
   ➡️ 외래 키 참조 무결성 제약조건 : 릴레이션 R1에 저장된 튜플이 릴레이션 R2에 있는 튜플을 참고하려면, 참조되는 튜플이 반드시 R2에 존재해야 한다는 제약조건입니다.  
   - 저장 공간을 효율적으로 사용합니다.
- 단점
   - 조회할 때 조인이 많이 사용되므로 성능이 저하될 수 있습니다.
   - 조회 쿼리가 복잡합니다.
   - 데이터를 등록할 INSERT SQL을 두 번 실행합니다.

### 1.2 단일 테이블 전략
단일 테이블 전략은 테이블을 하나만 사용하며 앞서 살펴본 조인 전략과 마찬가지로 DTYPE을 사용하여 타입을 구분합니다.
자식 엔티티가 매핑한 컬럼을 모두 null을 허용해야 합니다. 다양한 자식 엔티티들은 각자 자신이 필요한 컬럼에만 값을 부과할 것이기 때문입니다.

- 장점
   - 조인이 필요 없으므로 일반적으로 조회 성능이 빠릅니다.
   - 조회 쿼리가 단순합니다.
- 단점
   - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있습니다. 그러므로 상황에 따라서는 조 성능이 오히려 느려질 수 있습니다.

### 1.3 구현 클래스마다 테이블 전략
구현 클래스마다 테이블 전략은 자식 엔티티마다 테이블을 만드는 전략입니다.

- 장점
   - 서브 타입을 구분해서 처리할 때 효과적입니다.
   - not null 제약조건을 사용할 수 있습니다.
- 단점
   - 여러 자식 테이블을 함께 조회할 때 성능이 느립니다.
   - 자식 테이블을 통합해서 쿼리하기 어렵습니다.

❗ 일반적으로 추천하지 않는 전략이며 조인이나 단일 테이블 전략을 고려합시다!

## 2. @MappedSuperclass
@MappedSuperclass는 부모 클래스는 테이블과 매핑하지 않고 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공하고 싶을 때 사용합니다.

- 테이블과 매핑되지 않고 자식 클래스에 엔티티의 매핑 정보를 상속하기 위해 사용합니다.
- @MappedSuperclass로 지정한 클래스는 엔티티가 아니므로 em.find()나 JPQL에서 사용할 수 없습니다.
- 이 클래스를 직접 생성해서 사용할 일은 거의 없으므로 추상 클래스로 만드는 것을 권장합니다.

✌️ 등록일자, 수정일자, 등록자, 수정자 같은 여러 엔티티에서 공통으로 사용하는 속성을 효과적으로 관리할 수 있습니다.
